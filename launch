#!/usr/bin/exec-suid --real -- /bin/bash -p

set -euo pipefail
umask 077

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if [ -d /run/dojo ]; then
    WORK_DIR="/challenge/work"
    CHALLENGE_DIR="/challenge"
    SNAPSHOT_FILE="$SCRIPT_DIR/drive-c-snapshot"
    PRIVILEGED=0
    if [ -f /run/dojo/sys/workspace/privileged ]; then
        read -n1 PRIVILEGED < /run/dojo/sys/workspace/privileged
    fi
else
    WORK_DIR=$(mktemp -d)
    CHALLENGE_DIR="$SCRIPT_DIR"
    SNAPSHOT_FILE="/tmp/drive-c-snapshot-$(basename $SCRIPT_DIR)"
    PRIVILEGED=1
fi

mkdir -p "$WORK_DIR"

DISK_DIR="$SCRIPT_DIR/floppies"
DRIVE_C="$WORK_DIR/drive-c.raw"
DRIVE_D="$WORK_DIR/drive-d.raw"
MONITOR_PIPE="$WORK_DIR/qemu-monitor"
DISK_SIZE="${DISK_SIZE:-128M}"
USER_D_DIR="/home/hacker/d:"

BRIDGE_NAME="br-qemu$$"
TAP_DOS="tap-dos$$"
FLAG_NS="nsflag$$"
VETH_HOST="vfh$$"
VETH_NS="vfn$$"

FLAG_SERVER_IP="192.168.13.37"
FLAG_SERVER_PORT=1337

DOS_PID=""
CAT_PID=""
FLAG_SERVER_PID=""
SYNC_PID=""

if [ -z "${DISPLAY-}" ]; then
    echo "You must run this script from the desktop environment!"
    exit 1
fi

# Read VGA text mode screen and output to stdout
# $1: monitor fifo
read_vga_screen() {
    local monitor_fifo="$1"
    local vga_dump="$WORK_DIR/vga_dump.bin"
    echo "pmemsave 753664 4000 \"$vga_dump\"" > "$monitor_fifo"
    sleep 0.5
    [ ! -f "$vga_dump" ] && return 1
    od -An -tx1 -v "$vga_dump" | tr -d ' \n' | sed 's/../& /g' | gawk '{
        for (i=1; i<=NF; i+=2) {
            hex = $i
            dec = strtonum("0x" hex)
            if (dec >= 32 && dec <= 126) printf "%c", dec
            else printf " "
        }
    }' | fold -w 80 | sed 's/[[:space:]]*$//' | sed -e :a -e '/^[[:space:]]*$/d;N;ba' -e 's/\n$//'
    rm -f "$vga_dump"
}

# Type content to QEMU via sendkey commands
# $1: monitor fifo
# $2: content to type
# $3: if set, press Home after every newline (to fight autoindent)
type_content() {
    local monitor_fifo="$1"
    local content="$2"
    local home_after_newline="$3"

    while IFS= read -r -n1 char; do
        [ -z "$char" ] && char=$'\n'
        key=""
        case "$char" in
            [a-z]) key="$char" ;;
            [A-Z]) key="shift-$(echo "$char" | tr '[:upper:]' '[:lower:]')" ;;
            [0-9]) key="$char" ;;
            ' ') key="spc" ;;
            $'\n') key="ret" ;;
            $'\t') key="tab" ;;
            '-') key="minus" ;;
            '=') key="equal" ;;
            '[') key="bracket_left" ;;
            ']') key="bracket_right" ;;
            ';') key="semicolon" ;;
            "'") key="apostrophe" ;;
            '`') key="grave_accent" ;;
            '\\') key="backslash" ;;
            ',') key="comma" ;;
            '.') key="dot" ;;
            '/') key="slash" ;;
            '!') key="shift-1" ;;
            '@') key="shift-2" ;;
            '#') key="shift-3" ;;
            '$') key="shift-4" ;;
            '%') key="shift-5" ;;
            '^') key="shift-6" ;;
            '&') key="shift-7" ;;
            '*') key="shift-8" ;;
            '(') key="shift-9" ;;
            ')') key="shift-0" ;;
            '_') key="shift-minus" ;;
            '+') key="shift-equal" ;;
            '{') key="shift-bracket_left" ;;
            '}') key="shift-bracket_right" ;;
            ':') key="shift-semicolon" ;;
            '"') key="shift-apostrophe" ;;
            '~') key="shift-grave_accent" ;;
            '|') key="shift-backslash" ;;
            '<') key="shift-comma" ;;
            '>') key="shift-dot" ;;
            '?') key="shift-slash" ;;
            *) continue ;;  # Skip unsupported characters
        esac
        if [ -n "$key" ]; then
            echo "sendkey $key" > "$monitor_fifo"
            sleep 0.05
            # Press Home after newline if requested
            if [ -n "$home_after_newline" ] && [ "$key" = "ret" ]; then
                echo "sendkey home" > "$monitor_fifo"
                sleep 0.005
            fi
        fi
    done <<< "$content"
}

should_sync_filename() {
    local name="$1"
    local upper=$(echo "$name" | tr '[:lower:]' '[:upper:]')
    [[ "$upper" != "FLAG.TXT" ]] && [[ "$name" =~ ^[A-Za-z0-9_~!@#$%^\&\(\)\-\{\}\']{1,8}(\.[A-Za-z0-9_~!@#$%^\&\(\)\-\{\}\']{1,3})?$ ]]
}

copy_dir_to_dos() {
    local src="$1" img="$2"
    local hacker_user=$(stat -c '%U' /home/hacker 2>/dev/null) || return 0
    [ -z "$hacker_user" ] && return 0
    [ ! -d "$src" ] && return 0
    local part_offset=$(fdisk -l "$img" -o Start | tail -1)

    for f in "$src"/*; do
        [ ! -f "$f" ] && continue
        local name=$(basename "$f")
        should_sync_filename "$name" || continue
        local upper=$(echo "$name" | tr '[:lower:]' '[:upper:]')
        # Copy via temp file as hacker user to prevent symlink privilege escalation
        local tmp=$(mktemp -u)
        if runuser -u "$hacker_user" -- cp "$f" "$tmp" 2>/dev/null; then
            mcopy -omp -i "$img@@$((part_offset * 512))" "$tmp" "::$upper" 2>/dev/null || true
        fi
        rm -f "$tmp"
    done
}

copy_dos_to_dir() {
    local img="$1" dest="$2"
    local hacker_user=$(stat -c '%U' /home/hacker 2>/dev/null) || return 0
    [ -z "$hacker_user" ] && return 0
    local part_offset=$(fdisk -l "$img" -o Start | tail -1)
    local tmp=$(mktemp -d)
    chmod 755 "$tmp"
    mcopy -smp -i "$img@@$((part_offset * 512))" "::*" "$tmp/" 2>/dev/null || true
    runuser -u "$hacker_user" -- mkdir -p "$dest" 2>/dev/null || true

    for f in "$tmp"/*; do
        [ ! -f "$f" ] && continue
        local name=$(basename "$f")
        [[ "$(echo "$name" | tr '[:lower:]' '[:upper:]')" = "FLAG.TXT" ]] && continue
        chmod 644 "$f"
        local existing=$(ls "$dest" 2>/dev/null | grep -ix "$name" | head -1)
        [ -n "$existing" ] && name="$existing"
        [ -f "$dest/$name" ] && [ ! "$f" -nt "$dest/$name" ] && continue
        # Runs as hacker user to prevent symlink privilege escalation
        runuser -u "$hacker_user" -- cp "$f" "$dest/$name" 2>/dev/null || true
    done
    rm -rf "$tmp"
}

monitor_menu() {
    local monitor_fifo="$1"

    local term_height term_width
    term_height=$(tput lines 2>/dev/null || echo 24)
    term_width=$(tput cols 2>/dev/null || echo 80)
    local menu_height=$((term_height * 80 / 100))
    local menu_width=$((term_width * 80 / 100))
    [ $menu_height -lt 15 ] && menu_height=15
    [ $menu_height -gt 40 ] && menu_height=40
    [ $menu_width -lt 50 ] && menu_width=50
    [ $menu_width -gt 100 ] && menu_width=100
    local list_height=$((menu_height - 8))

    while true; do
        # Check if QEMU is still running
        if [ -n "$DOS_PID" ] && ! kill -0 "$DOS_PID" 2>/dev/null; then
            return 0
        fi

        local menu_items=(
            "load"      "Load floppy disk"
            "paste"     "Paste clipboard contents"
            "paste-home" "Paste clipboard (Home after newline)"
            "copy"      "Copy screen text to clipboard"
            "eject"     "Eject floppy"
            "reboot"    "Reboot system"
        )
        if [ "$PRIVILEGED" = "1" ]; then
            menu_items+=("monitor" "DEBUG: QEMU monitor console")
        fi
        menu_items+=("quit" "Quit (saves snapshot)")

        choice=$(whiptail --title "QEMU Floppy/System Control" --menu "Select an action:" $menu_height $menu_width $list_height \
            "${menu_items[@]}" \
            3>&1 1>&2 2>&3) || choice="quit"

        case "$choice" in
            load)
                disks=()
                [ -d "$DISK_DIR" ] && mapfile -t disks < <(find -L "$DISK_DIR" -type f 2>/dev/null | sort)
                # Also include any floppy images in the work directory
                while IFS= read -r -d '' f; do
                    disks+=("$f")
                done < <(find -L "$WORK_DIR" -maxdepth 1 -name "*.img" -print0 2>/dev/null | sort -z)

                if [ ${#disks[@]} -eq 0 ]; then
                    whiptail --title "Error" --msgbox "No floppy images found in disks/" $((menu_height / 2)) $((menu_width / 2))
                    continue
                fi

                menu_items=()
                for i in "${!disks[@]}"; do
                    disk_path="${disks[$i]}"
                    if [[ "$disk_path" == "$WORK_DIR"/* ]]; then
                        rel_path="$(basename "$disk_path")"
                    else
                        # Strip DISK_DIR and leading slash
                        rel_path="${disk_path#$DISK_DIR/}"
                    fi
                    menu_items+=("$i" "$rel_path")
                done

                disk_choice=$(whiptail --title "Select Floppy Disk" --menu "Available images:" $menu_height $menu_width $list_height \
                    "${menu_items[@]}" \
                    3>&1 1>&2 2>&3) || continue

                selected="${disks[$disk_choice]}"
                echo "change floppy0 $selected" > "$monitor_fifo"
                whiptail --title "Success" --msgbox "Loaded: ${selected#$WORK_DIR/}" $((menu_height / 2)) $menu_width
                ;;
            paste|paste-home)
                # Get clipboard contents
                content="$(xclip -selection clipboard -o 2>/dev/null || xsel --clipboard --output 2>/dev/null || "")"

                if [ -z "$content" ]; then
                    whiptail --title "Error" --msgbox "Clipboard is empty or xclip/xsel not available" $((menu_height / 2)) $menu_width
                    continue
                fi

                # Check if content starts with "pwn"
                if [[ "$content" == pwn* ]]; then
                    whiptail --title "Error" --msgbox "Clipboard content cannot start with 'pwn'" $((menu_height / 2)) $menu_width
                    continue
                fi

                whiptail --title "Pasting" --infobox "Sending keystrokes..." $((menu_height / 3)) $((menu_width / 2))
                if [ "$choice" = "paste-home" ]; then
                    type_content "$monitor_fifo" "$content" 1
                else
                    type_content "$monitor_fifo" "$content"
                fi
                whiptail --title "Success" --msgbox "Finished pasting clipboard contents" $((menu_height / 2)) $menu_width
                ;;
            copy)
                whiptail --title "Copy" --infobox "Reading screen text..." $((menu_height / 3)) $((menu_width / 2))
                local screen_text
                if ! screen_text=$(read_vga_screen "$monitor_fifo"); then
                    whiptail --title "Error" --msgbox "Failed to dump VGA memory" $((menu_height / 2)) $menu_width
                    continue
                fi

                if [ -z "$screen_text" ]; then
                    whiptail --title "Error" --msgbox "No text found (system may be in graphics mode)" $((menu_height / 2)) $menu_width
                    continue
                fi

                # Copy to clipboard
                echo -n "$screen_text" | xclip -selection clipboard 2>/dev/null || \
                echo -n "$screen_text" | xsel --clipboard --input 2>/dev/null || {
                    whiptail --title "Error" --msgbox "Failed to copy to clipboard (xclip/xsel not available)" $((menu_height / 2)) $menu_width
                    continue
                }

                local line_count
                line_count=$(echo "$screen_text" | wc -l)
                whiptail --title "Success" --msgbox "Copied $line_count lines to clipboard" $((menu_height / 2)) $menu_width
                ;;
            eject)
                echo "eject floppy0" > "$monitor_fifo"
                whiptail --title "Success" --msgbox "Floppy ejected" $((menu_height / 2)) $((menu_width / 2))
                ;;
            reboot)
                echo "system_reset" > "$monitor_fifo"
                whiptail --title "Success" --msgbox "System reset sent" $((menu_height / 2)) $((menu_width / 2))
                ;;
            monitor)
                clear
                echo "QEMU Monitor - Enter commands (Ctrl-D or empty line to exit)"
                echo "-----------------------------------------------------------"
                tail -f "${MONITOR_PIPE}.log" 2>/dev/null &
                local tail_pid=$!
                while IFS= read -rep "(qemu) " cmd; do
                    [ -z "$cmd" ] && break
                    echo "$cmd" > "$monitor_fifo"
                done
                kill "$tail_pid" 2>/dev/null
                ;;
            quit)
                echo "Saving C: snapshot for next start..."
                if [ -n "$DOS_PID" ] && kill -0 "$DOS_PID" 2>/dev/null; then
                    echo "commit ide0-hd0" > "$monitor_fifo"
                    echo "commit ide0-hd1" > "$monitor_fifo"
                    echo "quit" > "$monitor_fifo"
                    wait $DOS_PID 2>/dev/null || true
                fi
                cp "$DRIVE_C" "$SNAPSHOT_FILE"
                copy_dos_to_dir "$DRIVE_D" "$USER_D_DIR"
                return 0
                ;;
        esac
    done
}

cleanup() {
    [ -n "$FLAG_SERVER_PID" ] && kill "$FLAG_SERVER_PID" 2>/dev/null || true
    [ -n "$DOS_PID" ] && kill "$DOS_PID" 2>/dev/null || true
    [ -n "$CAT_PID" ] && kill "$CAT_PID" 2>/dev/null || true
    [ -n "$SYNC_PID" ] && kill "$SYNC_PID" 2>/dev/null || true
    rm -f "${MONITOR_PIPE}.in" "${MONITOR_PIPE}.out" 2>/dev/null || true
    ip netns del "$FLAG_NS" 2>/dev/null || true
    ip link set "$TAP_DOS" down 2>/dev/null || true
    ip link del "$TAP_DOS" 2>/dev/null || true
    ip link del "$VETH_HOST" 2>/dev/null || true
    ip link set "$BRIDGE_NAME" down 2>/dev/null || true
    ip link del "$BRIDGE_NAME" 2>/dev/null || true
    rm -f "$DRIVE_C" "$DRIVE_D"
    exit 0
}

trap cleanup EXIT INT TERM

for i in $(seq 0 7); do
    [ -e /dev/loop$i ] || mknod /dev/loop$i b 7 $i
done

if [ -f "$SNAPSHOT_FILE" ]; then
    cp "$SNAPSHOT_FILE" "$DRIVE_C"
else
    if [ -f "$SCRIPT_DIR/drive-c" ]; then
        cp "$SCRIPT_DIR/drive-c" "$DRIVE_C"
    else
        qemu-img create -f raw "$DRIVE_C" "$DISK_SIZE"
        parted "$DRIVE_C" --script mklabel msdos mkpart primary fat32 1MiB 100% set 1 boot on 2>/dev/null
    fi

    if [ -d "$CHALLENGE_DIR/c_files" ] && [ "$(ls -A "$CHALLENGE_DIR/c_files" 2>/dev/null)" ]; then
        PART_OFFSET=$(fdisk -l "$DRIVE_C" -o Start | tail -1)
        mcopy -o -i "$DRIVE_C@@$((PART_OFFSET * 512))" -s "$CHALLENGE_DIR/c_files/"* ::
    fi
fi

# Create drive-d (always, like drive-c)
if [ -f "$CHALLENGE_DIR/drive-d" ]; then
    cp "$CHALLENGE_DIR/drive-d" "$DRIVE_D"
else
    qemu-img create -f raw "$DRIVE_D" 16M
    sfdisk "$DRIVE_D" >/dev/null 2>&1 <<EOF
label: dos
start=32, type=0x01, bootable
EOF
    PART_OFFSET=$(fdisk -l "$DRIVE_D" -o Start | tail -1)
    mformat -i "$DRIVE_D@@$((PART_OFFSET * 512))"
fi

# Copy user files from /home/hacker/d:/ to D:
copy_dir_to_dos "$USER_D_DIR" "$DRIVE_D"

ip link add "$BRIDGE_NAME" type bridge
ip link set "$BRIDGE_NAME" up

# Create tap device for DOS VM (restricted to current user and group)
ip tuntap add dev "$TAP_DOS" mode tap user "$(whoami)" group "$(id -gn)"
ip link set "$TAP_DOS" master "$BRIDGE_NAME"
ip link set "$TAP_DOS" up

ip netns add "$FLAG_NS"
ip link add "$VETH_HOST" type veth peer name "$VETH_NS"
ip link set "$VETH_HOST" master "$BRIDGE_NAME"
ip link set "$VETH_HOST" up
ip link set "$VETH_NS" netns "$FLAG_NS"
ip netns exec "$FLAG_NS" ip link set lo up
ip netns exec "$FLAG_NS" ip link set "$VETH_NS" up
ip netns exec "$FLAG_NS" ip addr add "${FLAG_SERVER_IP}/24" dev "$VETH_NS"

if cat "$CHALLENGE_DIR/.config.ini" 2>/dev/null | grep -q "flag=network"; then
    ip netns exec "$FLAG_NS" socat "TCP-LISTEN:${FLAG_SERVER_PORT},bind=${FLAG_SERVER_IP},reuseaddr,fork" SYSTEM:"cat /flag" &
    FLAG_SERVER_PID=$!
elif cat "$CHALLENGE_DIR/.config.ini" 2>/dev/null | grep -q "flag=a"; then
    FLOPPY_FLAG="$WORK_DIR/flag-floppy.img"
    mkfs.vfat -C "$FLOPPY_FLAG" 1440
    mcopy -o -i "$FLOPPY_FLAG" /flag ::FLAG.TXT
elif cat "$CHALLENGE_DIR/.config.ini" 2>/dev/null | grep -q "flag=c"; then
    PART_OFFSET=$(fdisk -l "$DRIVE_C" -o Start | tail -1)
    mcopy -o -i "$DRIVE_C@@$((PART_OFFSET * 512))" /flag ::FLAG.TXT
elif cat "$CHALLENGE_DIR/.config.ini" 2>/dev/null | grep -q "flag=d"; then
    PART_OFFSET=$(fdisk -l "$DRIVE_D" -o Start | tail -1)
    mcopy -o -i "$DRIVE_D@@$((PART_OFFSET * 512))" /flag ::FLAG.TXT
fi

mkfifo "${MONITOR_PIPE}.in"
mkfifo "${MONITOR_PIPE}.out"

qemu-system-x86_64 \
    -name dos \
    -m 16M \
    -smp 1 \
    -rtc base=localtime \
    -drive file="$DRIVE_C",format=raw,if=ide \
    -drive file="$DRIVE_D",format=raw,if=ide,index=2 \
    -boot d \
    -netdev tap,id=net0,ifname="$TAP_DOS",script=no,downscript=no \
    -device pcnet,netdev=net0,mac=52:54:00:12:34:56 \
    -monitor pipe:"$MONITOR_PIPE" \
    -parallel none \
    -vga cirrus \
    >&/dev/null &

DOS_PID=$!

# Open the output pipe to prevent blocking, discard output
cat "${MONITOR_PIPE}.out" > "${MONITOR_PIPE}.log" &
CAT_PID=$!

# Wait a moment for QEMU to open the pipes
sleep 1

# Background D: sync - every 5s, sync files modified in last minute
(
    set -x
    p=$(($(fdisk -l "$DRIVE_D" -o Start | tail -1)*512))
    while sleep 5; do
        t=$(date +"%-H:%M"); t0=$(date -d "-1min" +"%-H:%M")
        mdir -i "$DRIVE_D@@$p" 2>/dev/null | grep -qE " ($t|$t0) " && copy_dos_to_dir "$DRIVE_D" "$USER_D_DIR"
    done
) >& $WORK_DIR/sync.log &
SYNC_PID=$!

if [ -d "$CHALLENGE_DIR/launch.d" ]; then
    for script in "$CHALLENGE_DIR/launch.d"/*; do
        [ -f "$script" ] && [ -x "$script" ] && source "$script" "${MONITOR_PIPE}.in"
    done
fi

monitor_menu "${MONITOR_PIPE}.in"
wait $DOS_PID 2>/dev/null || true
